/* 
OLD ROBOT TEST WITH CODE FOR DISPLAYING TO LCD
*/
#include <QTRSensors.h>
#include <Wire.h>
#include <Adafruit_MotorShield.h>
#include <LiquidCrystal.h>
#include "utility/Adafruit_MS_PWMServoDriver.h"
#define trigPin 8
#define echoPin 13
#define NUM_SENSORS   4    // number of sensors used
#define TIMEOUT       2500  // waits for 2500 microseconds for sensor outputs to go low
#define EMITTER_PIN   QTR_NO_EMITTER_PIN     // emitter is controlled by digital pin 2

// Initialize the pins for the LCD.
LiquidCrystal lcd(7,6,5,4,3,2);

// sensors 0 through 7 are connected to digital pins 3 through 10, respectively
QTRSensorsRC qtrrc((unsigned char[]) {A0, A1, A2, A3},
  NUM_SENSORS, TIMEOUT, EMITTER_PIN); 
unsigned int sensorValues[NUM_SENSORS];

// Create the motor shield object with the default I2C address
Adafruit_MotorShield AFMS = Adafruit_MotorShield(); 
// Or, create it with a different I2C address (say for stacking)
// Adafruit_MotorShield AFMS = Adafruit_MotorShield(0x61); 

// Select which 'port' M1, M2, M3 or M4. In this case, M1
Adafruit_DCMotor *myMotor1 = AFMS.getMotor(1);
Adafruit_DCMotor *myMotor2= AFMS.getMotor(2);
Adafruit_DCMotor *myMotor3 = AFMS.getMotor(3);
Adafruit_DCMotor *myMotor4 = AFMS.getMotor(4);
// You can also make another motor on port M2
//Adafruit_DCMotor *myOtherMotor = AFMS.getMotor(2);

void setup() {
  Serial.begin(9600);           // set up Serial library at 9600 bps
  Serial.println("Adafruit Motorshield v2 - DC Motor test!");
  
  lcd.begin(16, 2); // LCD is 2 lines of 16 chars
  //lcd.clear();
  //lcd.print("Adafruit Motorshield v2 - DC Motor test!");
  
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
   AFMS.begin();  // create with the default frequency 1.6KHz
  //AFMS.begin(1000);  // OR with a different frequency, say 1KHz
  
  // Set the speed to start, from 0 (off) to 255 (max speed)
  myMotor1->setSpeed(0);
  myMotor1->run(FORWARD);
  // turn on motor
  myMotor1->run(RELEASE);
  
  myMotor2->setSpeed(0);
  myMotor2->run(FORWARD);
  // turn on motor
  myMotor2->run(RELEASE);
  
  myMotor3->setSpeed(0);
  myMotor3->run(FORWARD);
  // turn on motor
  myMotor3->run(RELEASE);
  
  myMotor4->setSpeed(0);
  myMotor4->run(FORWARD);
  // turn on motor
  myMotor4->run(RELEASE);
  Serial.println("tea1");
}

void loop() {
  uint8_t i;
  
  long duration, distance;

  /*
  // when characters arrive over the serial port...
  if (Serial.available()) {
    // wait a bit for the entire message to arrive
    delay(100);
    // clear the screen
    lcd.clear();
    // read all the available characters
    while (Serial.available() > 0) {
      // display each character to the LCD
      lcd.print(Serial.read());
    }
  }
 */
   
 //  delayMicroseconds(1000); - Removed this line
   delayMicroseconds(10); // Added this line
   digitalWrite(trigPin, LOW);
   delayMicroseconds(2); // Added this line
   digitalWrite(trigPin, HIGH);
   delayMicroseconds(5);
   digitalWrite(trigPin,LOW);
   duration = pulseIn(echoPin, HIGH);
   distance = (duration/2) / 29.1;
   
   qtrrc.read(sensorValues);

  // print the sensor values as numbers from 0 to 1000, where 0 means maximum reflectance and
  // 1000 means minimum reflectance, followed by the line position
   // uncomment this line if you are using raw values
 // Serial.println(position); // comment this line out if you are using raw values
   
   
     Serial.print(distance);
     Serial.println(" cm");
     lcd.setCursor(1,0);
     lcd.clear();
     lcd.print(distance);

     lcd.setCursor(0,1);
     //lcd.println(" cm"); 
   
   
  
  if (sensorValues[0] < 1000 && distance > 10)
  {
    myMotor1->setSpeed(100);
    myMotor2->setSpeed(110);
    myMotor3->setSpeed(110);
    myMotor4->setSpeed(100);
    myMotor1->run(FORWARD);
    myMotor2->run(FORWARD);
    myMotor3->run(FORWARD);
    myMotor4 ->run(FORWARD);
        delay(500);
    
  }
  else if (sensorValues[3] < 1000 && distance > 10)
  {
    myMotor1->setSpeed(110);
    myMotor2->setSpeed(100);
    myMotor3->setSpeed(100);
    myMotor4->setSpeed(110);
    myMotor1->run(FORWARD);
    myMotor2->run(FORWARD);
    myMotor3->run(FORWARD);
    myMotor4 ->run(FORWARD);
        delay(500);
    
  }
  else if (distance < 10)
  {
    myMotor1->setSpeed(200);
    myMotor2->setSpeed(200);
    myMotor3->setSpeed(200);
    myMotor4->setSpeed(200);
    myMotor1->run(BACKWARD);
    myMotor2->run(BACKWARD);
    myMotor3->run(BACKWARD);
    myMotor4 ->run(BACKWARD);
    delay (50);
  }
    
  else
  {
  
  
    myMotor1->setSpeed(100);
    myMotor2->setSpeed(100);
    myMotor3->setSpeed(100);
    myMotor4->setSpeed(100);
    myMotor1->run(FORWARD);
    myMotor2->run(FORWARD);
    myMotor3->run(FORWARD);
    myMotor4 ->run(FORWARD);
        delay(500);
  }
        
   for (unsigned char i = 0; i < NUM_SENSORS; i++)
  {
    Serial.print(sensorValues[i]);
    Serial.print('\t');

    //delay(1000);
    //lcd.print(sensorValues[i]);
    //delay(1000);
    

  }
  Serial.println();

  lcd.print(sensorValues[i]);
  lcd.print(sensorValues[i+1]);
  lcd.print(sensorValues[i+2]);
  lcd.print(sensorValues[i+3]);
  delay(1000);
  
  }
  
 

  
